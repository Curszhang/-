### 1. HTML 有哪些行内元素

行内元素：a img span b strong input select section

### 2. HTML 有哪些语义化标签

```
<title>：页面主体内容。
<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。
<ul>：无序列表。
<li>：有序列表。
<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。
<nav>：标记导航，仅对文档中重要的链接群使用。
<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。
<article>：定义外部的内容，其中的内容独立于文档的其余部分。
<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。
<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。
<footer>：页脚，只有当父级是body时，才是整个页面的页脚。
<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。
<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。
<em>：将其中的文本表示为强调的内容，表现为斜体。
<mark>：使用黄色突出显示部分文本。
<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。
<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。
<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。
<blockquoto>：定义块引用，块引用拥有它们自己的空间。
<q>：短的引述（跨浏览器问题，尽量避免使用）。
<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。
<abbr>：简称或缩写。
<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。
<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。
<del>：移除的内容。
<ins>：添加的内容。
<code>：标记代码。
<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）
<progress>：定义运行中的进度（进程）。
```

### 3. 常用的 meta 标签有哪些

```
（1）charset，用来描述HTML文档的编码类型：
<meta charset="UTF-8" >
（2） keywords，页面关键词：
<meta name="keywords" content="关键词" />
（3）description，页面描述：
<meta name="description" content="页面描述内容" />
（4）refresh，页面重定向和刷新：
<meta http-equiv="refresh" content="0;url=" />
（5）viewport，适配移动端，可以控制视口的大小和比例：
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
```

### 4. HTML5 新特性

```
（1）、语义化标签，例如header，footer，section，article等 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；
（2）新增媒体元素，audio、video audio和video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API
（3）.用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的canvas元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。
（4）新增本地存储方式：sessionStorage、localStorage
sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。
localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。
（5）新的技术：webworker、websocket webworker：用于多线程编程
websocket：客户端与服务端双向数据通信协议
```

### 5. h5 新增的表单类型

```
●email类型:
该类型会自动要求输入的地址格式正确，否则浏览器不允许提交，并且有一个错误的信息提示
email类型的文本框具有一个multiple属性，该属性允许在文本框中输入使用逗号分隔有效的E-mail地址的一个列表。
●url类型:
url类型：
是用来专门输入url地址的输入框，例如百度地址和谷歌地址。
●number类型:
是用来专门输入数字的文本框，在提交时会检测其中内容是否为数字。
number类型的属性：
max 指定输入框可以接受的最大的输入值
min 指定输入框可以接受的最小的输入值
step 输入域合法的间隔，如果不设置，默认为1
value 指定默认显示的数值
●range类型:
只允许输入一段范围内数值的文本框。以滑动条的形式展示数字，通过拖动滑块实现数字的改变。
range类型的属性：
max 指定输入框可以接受的最大的输入值
min 指定输入框可以接受的最小的输入值
step 输入域合法的间隔，如果不设置，默认为1
value 指定默认显示的数值
●tel类型:
用来输入电话号码的专用文本框。tel类型的文本框通常用来验证固定的电话和手机号码。如果只将input元素的类型
设置为tel,并不会达到验证电话的效果，它必须和pattern属性一起使用。
●color类型:
用来选取颜色的，它提供一个颜色选取器用来选取。
●search类型
search类型是一种专门用来输入搜索关键词的文本框.
不同于普通类型的文本框在于，当用户开始输入时，输入框的右边会出现一个用于清除内容的图标，单机可以快速清除。
●新增日期与时间类型：
HTML5新增6个日期类型：date、time、datetime、datatime-local、month、week
●date类型:
以日历的形式方便用户输入
●time类型:
是一种专门用来输入时间的文本框，并且在提交时会对输入时间的有效性进行检查 -->
●datetime类型:
是一种专门用来输入UTC日期和时间的文本框，它不仅可以显示年月日，还可以显示具体时间。
设置datetime类型完成后，在提交时会对用户输入或选择的日期和时间进行有效性检测。
●datetime-local类型:
datetime-local类型：是用来专门输入本地日期和时间的文本框，并且在提交时会进行检测。
●month类型:
专门用来输入月份的文本框，提交时会进行检查
●week类型:
是一种专门用来输入周的文本框，并且在提交会进行检查
```

### 6. css 里有哪些选择器

1、类别选择器；2、标签选择器；3、ID 选择器；4、后代选择器；5、子选择器；6、伪类选择器；7、通用选择器；8、群组选择器；9、相邻同胞选择器；10、属性选择器；11、伪元素选择器。

### 7. 伪类选择器和伪元素选择器

伪类：一般表示状态，例如 hover
伪元素：可以把元素呈现在页面而不再 dom 树里面

### 8. 选择器的权重

```
!important						最高优先级（慎用）
内联样式							1，0，0，0
id选择器				          	    0，1，0，0
类和伪类选择器	               	 0，0，1，0
元素选择器						0，0，0，1
通配选择器						0，0，0，0
继承的样式						没有优先级（最低）
```

### 9. 属性选择器的权重

### 10. CSS 中隐藏界面中某个元素的方法

```
1. overflow
.hide{
     overflow:hidden; /* 占据空间，无法点击 */
} overflow的hidden用来隐藏元素溢出部分，占据空间，无法响应点击事件。
2.opacity
.hide{
    opacity:0;/* 占据空间，可以点击 */
}
.hide_2{
    -webkit-filter:opacity(0);
    filter:opacity(0);/* 占据空间，可以点击 */
}
过滤元素filter也可使用opacity值设置透明度，不过filter现在的兼容性不好，只支持webkit内核，这里顺带一提。
opacity是用来设置元素透明度的，但当设置成0的时候也就相当于隐藏元素了。因此，元素依然存在原来的位置，占据空间也可响应事件。如果你打算使用 opacity 属性在读屏软件中隐藏元素，很不幸，你并不能如愿。元素和它所有的内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致。

3.visibility
.hide{
    visibility:hidden; /* 占据空间，无法点击 */
}  如同 opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏
4.display
.hide{
    display:none;/* 不占据空间，无法点击 */
}  经典的display隐藏元素,这个是彻底的隐藏了元素，不占据空间，也就不影响布局，当然也无法响应事件。
5.position
.hide{
    position：absolute;
    left:-99999px;
    top:-90999px;/* 不占据空间，无法点击 */
}
.hide-2{
    position：relative;
    left:-99999px;
    top:-90999px;/* 占据空间，无法点击 */
}  假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互——译者注）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既不会影响布局，有能让元素保持可以操作。下采用这种办法未尝不可。
6.clip/clip-path
.hide{
    position:absolute;/*fixed*/
    clip:rect(top,right,bottom,left);/* 占据空间，无法点击 */
}
.hide_2 {
  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);
}  隐藏元素的另一种方法是通过剪裁它们来实现。在以前，这可以通过 clip 属性来实现，但是这个属性被废弃了(现在浏览器依然支持)，换成一个更好的属性叫做 clip-path。clip-path属性实在是用处大大滴有，可以很容易的实现一些复杂的图形大漠老师分享的一个链接，该链接里的图形大多都是用clip-path的polygon值来实现的。但可惜的是依旧只能在chrome40+浏览器里使用.
7.z-index
.hide{
    position:absolute;
    z-index:-1000;/* 不占据空间，无法点击 */
}  通过设置z-index值使其它元素遮盖该元素也算是一种隐藏了。
8. transform
.hide{
    transform: scale(0,0)/* 占据空间，无法点击 */
}
```

### 11. 怎么让一个 div 水平垂直居中

```
方法一：
  绝对定位法，不确定当前div宽度和高度，采用 transform: translate(-50%,-50%);，当前div的父级添加相对定位（position: relative;）
方法二：
  绝对定位的方法：确定要居中的div宽度，margin值为要居中div宽度一半的负值。
方法三:
  绝对定位的方法：绝对定位下top、left、reign、bottom 都设置为0。
方法四：
  flex布局方法：当前div的父级添加flex css样式。
方法五：
  table-cell实现水平垂直居中：table-cell middle center 结合使用。垂直居中的如果是div 等块级元素，需设置display: inline-block;
方法六：
  绝对定位：calc( ) 函数动态计算水平居中。
```

### 12. CSS 如何左侧固定 300px，右侧自适应

### 13. CSS 盒模型

    盒模型：盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。
    IE 模型元素宽度 width = content + padding + border，高度计算相同，
    标准模型元素宽度 width=content，高度计算相同，

### 14. reset.css

### 15. 什么是 BFC（块格式化）

```
1.BFC 的概念
BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，块级格式上下文。

2.如何创建BFC？
根元素，即 HTML 元素
float 的值不为 none
overflow 的值不为 visible
position 的值为 absolute 或 fixed
display 的值为 inline-block、table-cell、table-caption
3.BFC的使用场景
去除边距重叠现象
清除浮动（让父元素的高度包含子浮动元素）
避免某元素被浮动元素覆盖
避免多列布局由于宽度计算四舍五入而自动换行
```

### 16. margin 重叠

```
    什么是 margin 重叠：
    两个或多个盒子可能（相邻）也可能（嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。
    有可能发生在父子元素，也有可能发生在兄弟元素之间
    发生在（垂直相邻边界），即上下
    结果的边界宽度是相邻边界宽度中（最大的值）
    边界的重叠也有例外情况：
    1、水平边距永远不会重合。
    2、在规范文档中，2 个或以上的块级盒模型相邻的垂直 margin 会重叠。最终的 margin 值计算方法如下：
    a、全部都为正值，取最大者；
    b、不全是正值，则都取绝对值，然后用正值减去最大值；
    c、没有正值，则都取绝对值，然后用 0 减去最大值。
    解决方法：
    对于父子元素：
    1、子层元素取消 margin，用父元素的 padding 代替
    2、内层元素透明边框 border:1px solid transparent; //这是基于最上面说的(其间没有任何非空内容、补白、边框)原理实现。
    3、内层元素设置为 BFC。（什么为 BFC 详见下一篇）
    对于兄弟元素：
    1、设置两个兄弟为两个 BFC 区域
    2、给其中一个兄弟套上一个 div，设置 border:1px solid white;也是用了(其间没有任何非空内容、补白、边框)原理实现。
```

### 17. CSS 单位（rpx）

```
1、 px(Pixel) 相对于显示器分辨率而言，表示“绝对尺寸”（并非真正的绝对），实际上就是css中定义的像素（这里的像素与设备的物理像素有一定的区别），利用px设置字体大小及元素宽高等比较稳定和精确。px的特点如下：

IE无法调整那些使用px作为单位的字体大小；
国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；
Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。
px不能适应浏览器缩放时产生的变化，因此一般不用于是响应式网站。
2、em 表示相对尺寸，其相对于当前对象内 (父级元素) 文本的字体尺寸 font-size（如当前对行内文本的字体尺寸未被设置，则相对于浏览器的默认字体尺寸。 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合：1em = 16px。）。使用em可以较好的相应设备屏幕尺寸的变化，但是在进行元素设置时都需要知道父元素文本的font-size及当前对象内文本的font-size，如有遗漏可能会导致错误。em的特点如下：
em的值并不是固定的；
em会继承父级元素的字体大小。
3、rem 为css3新增的一个相对单位，使用rem为元素设定字体大小时，仍然是相对大小，但是rem只相对于HTML根元素的font-size，因此只需要确定这一个font-size。使用rem的好处是只修改根元素就可以成比例的调整所有字体的大小，又可以避免字体大小逐层复合的连锁反应。

```

### 18. JS 基础数据类型有哪些

    值类型（简单/基本对象类型）和 引用类型（复杂/复杂对象类型）
    基本类型：在内存中占据固定大小，保存在栈内存中。
    Number（数字）
    String（字符串）
    Boolean（布尔）
    undefined（未定义）
    null（空）
    Symbol（符号）（ES6 新增的）
    引用类型：引用类型的值是对象，保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。

### 19. undefined 和 null

```
    （1）相同点
    第一：Undefined 和 Null 两种数据类型都只有一个字面值，分别是 undefined 和 null.
    第二：Undefined 和 Null 类型在转换为 Boolean 类型的值时，都会转换为 false.
    第三：在需要将两者转换成对象的时候，都会抛出一个 TypeError 的异常。
    var a;
    var b=null;
    cosnole.log(a.name);//Cannot read property 'name' of undefined
    cosnole.log(b.name);//Cannot read property 'name' of undefined
    第四：Undefined 类型派生自 Null 类型，所以在非严格相等的比较下，两者是相等的。如下面代码所示：
    null==undefined //true
    (2)不同点
    第一：null 是 JavaScript 的关键字，而 undefined 是 JavaScript 的一个全局变量，也就是挂载在 window 对象上的一个变量，并不是关键字。
    第二：在使用 typeof 运算符进行检测时，Undefined 类型的值会返回 undefined.而 Null 类型的值返回为 object
    typeof undefined ;//undefined
    typeof null ;//object
    第三：在需要进行字符串类型的转换时，null 会转换成字符串 null,而 undefined 会转换字符串 undefined.
    undefined+" abc" //"undefined abc"
    null+" abc" //"null abc"
    第四：在进行数值类型的转换时，undefined 会转换为 NaN,无法参与计算，而 null 会转换为 0,可以参与计算。
```

### 20. typeof null 返回什么？

    js 语言缺陷， 返回前三位，null 所有都是 0，所以返回 object

### 21. 0.1+0.2

    js 双精度，转为 2 进制 64 位，0.1，0.2 转为无线不循环，转回导致精度丢失。

### 22. instanceof 原理

    instanceof A，去找 A 的原型在不在 a 的隐式原型链上面

### 23. 原型，原型链

```
    prototype
    函数有原型，函数有一个属性叫 prototype，函数的这个原型指向一个对象，这个对象叫原型对象。这个原型对象有一个 constructor 属性，指向这个函数本身。
    **proto
    JavaScript 中，万物皆对象，任何东西都有**proto**属性。这个叫隐式原型。
    当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的**proto**隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的**proto\_\_中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
```

### 24. 作用域，作用域链

```
    定义 : 作用的范围,确定当前执行代码对变量的访问权限
    JavaScript 采用静态作用域
    静态作用域/词法作用域 : 函数作用域在函数定义的时候就已经确定了
    动态作用域 : 函数作用域在函数调用时才确定
    作用域链
    定义：当查找变量时，会从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象所构成的链表就叫作用域链
    定义函数时
    函数存在一个内部属性[[scope]],函数被创建时,就会保存所有的父变量对象到其中,不包含本身的变量对象
    注意 : [[scope]]不代表完整的作用域链
    执行函数时
    函数会创建执行上下文,激活变量对象生成活动对象 AO,再将 AO 压入到执行上下文的作用域中
```

### 25. 闭包

```
    1.闭包(closure):
    指有权访问另一个函数作用域中变量的函数。
    function fn() {
    var num = 10;
    function fun() {
    console.log(num);
    }
    fun();
    }
    fn(); 2.闭包的特点：
    函数嵌套函数。
    函数内部可以引用外部的参数和变量。
    参数和变量不会被垃圾回收机制回收。 3.闭包的优点：
    变量长期驻扎在内存中
    避免全局变量的污染
    私有成员的存在 4.闭包的缺点：
    函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏。 5.闭包的使用场景：
    1.setTimeout：
    原生的 setTimeout 传递的第一个函数不能带参数，通过闭包可以实现传参效果
```

### 26. var、let、const 的区别

```
声明方式	变量提升	暂时性死区	声明、使用顺序 / 重复声明	块作用域有效	跨块、跨函数访问
var	会	不存在	    允许先使用后声明 / 允许	不是	可以/不能
let	不会	存在	    先声明后使用 / 不允许	是	不能
const	不会	存在	    必须设置初始值，先声明后使用 / 不允许	是	不能
```

### 27. 变量提升，函数提升 1.变量声明提升

    · 通过 var 定义的变量，在定义语句之前就可以访问到；变量的声明会提升到函数的顶部，变量的赋值并不会
    · 值：undefined 2.函数声明提升
    · 通过 function 声明的函数，在之前就可以调用；函数表达式不会进行变量提升，只有函数声明形式才可以
    · 值：函数定义(对象)

### 28. 异步加载 js 脚本 async 和 defer 的区别

    有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行。
    有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

### 29. es6 新特性

```
    1.let & const
    2.解构赋值
    3.模板字符串
    4.简化对象写法：ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法（在属性名和变量名相同的情况下），这样的书写更加简洁
    5.箭头函数
    6.函数参数的默认值设置
    7.rest 参数 8.扩展运算符
    9.Symbol：ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第 7 种数据类型，是一个类似字符串的数据类型 10.迭代器：迭代器（iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 iterator 接口，就可以完成遍历操作 11.生成器：生成器本身是一个特殊的函数，生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数不同
    12.Promise
    Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果
    Promise 构造函数：Promise(excutor){}
    Promise.prototype.then 方法
    Promise.prototype.catch 方法
    13.set（集合）
    ES6 提供了新的数据结构 set(集合)，本质上是一个对象。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用「扩展运算符」和 for...of 进行遍历
    集合的属性和方法：
    size，返回集合的元素个数
    add，增加一个新元素，返回当前集合
    delete，删除元素，返回 Boolean 值
    has，检测集合中是否包含某个元素，返回 Boolean 值
    14.Map
    ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map 也实现了 iterator 接口，所以可以使用「扩展运算符」和 for...of 进行遍历
    Map 的属性和方法：
    size，返回 Map 的元素个数
    set，增加一个新元素，返回当前 Map
    get，返回键名对象的键值
    has，检测 Map 中是否包含某个元素，返回 Boolean 值
    clear，清空集合，返回 undefined
```
