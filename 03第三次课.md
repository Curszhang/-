###1. flex 布局的了解

```
以下由6个属性是对父元素设置的:
flex-direction：设置主轴的方向
justify-content：设置主轴上的子元素排列方式
flex-wrap：设置子元素是否换行
align-content：设置侧轴上的子元素的排列方式 (多行)
align-items：设置侧轴上的子元素的排列方式 (单行)
flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap

align-content 和 align-items:
align-items 适用于单行情况下，只有上对齐、下对齐、居中和拉伸
align-content 使用于换行(多行)的情况下(单行情况下无效)，可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值
总结就是单行找 align-itens 多行找 align-content

1、flex-direction：设置主轴的方向
主轴与侧轴
在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x轴和y轴
默认主轴方向就是 x 轴方向，水平向右
默认侧轴方向就是 y 轴方向，垂直向下

2、 justify-content：主轴上的子元素排列方式
justify-content 属性定义了项目在主轴上的对齐方式

3、flex-wrap：子元素是否换行
默认情况下，项目都排在一条线(又称"轴线")上
flex-wrap属性定义，flex布局中默认是不换行的

4、align-content：侧轴上的子元素的排列方式 (多行)
设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况(多行)，在单行下没有效果

5、align-items：侧轴上的子元素的排列方式 (单行)
该属性是控制子项在侧轴(默认是 y 轴) 上的排列方式
在子项为单项(单行)的时候使用

6、flex-flow
flex-flow 属性是复合属性， flex-direction 和 flex-wrap 属性的复合属性

```

###2. 响应式布局

```
1、百分比布局
百分比是相对于 包含块 的计量单位，通过对属性设置百分比来适应不同的屏幕
包含块：
1. 有父元素相对于父元素
2. 无父元素相对于视口
3. 或者继承于父元素

2、rem布局

3 媒体查询 @media screen

4 flex布局

5、vw 和 vh
```

###3. 移动端布局

```
一、百分比布局
二、flex布局
----flex 是 flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。
flex布局又称为：
伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 =flex布局
三、rem
```

###4. rem 原理

```
rem是响应式布局的一种，是相对于根元素(即html元素)font-size计算值的倍数的一个css单位。因为rem的特性相对长度单位，常被用来做移动适配，pc端页面不推荐使用rem
rem布局的本质是等比缩放，一般是基于宽度针对设计稿的宽度 利用js动态获取屏幕的宽度
rem是相对于根元素的字体大小的单位，也就是html的font-size大小，浏览器默认的字体大小是16px，所以默认的1rem=16px

```

###5. css3 的新特性

```
1.过渡属性
transition： 要改变的属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)

 2.动画属性
animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）

 3.圆角属性：
CSS border-radius - 指定每个角
border-radius 属性可以接受一到四个值。规则如下：

四个值 - border-radius: 15px 50px 30px 5px;（依次分别用于：左上角、右上角、右下角、左下角）：

三个值 - border-radius: 15px 50px 30px;（第一个值用于左上角，第二个值用于右上角和左下角，第三个用于右下角）：

两个值 - border-radius: 15px 50px;（第一个值用于左上角和右下角，第二个值用于右上角和左下角）：

一个值 - border-radius: 15px;（该值用于所有四个角，圆角都是一样的）：
4.引入了rgba
5.背景色渐变
6.盒子阴影
7.弹性布局，栅格布局
```

###6. 查找下一个兄弟元素

```
查找下一个兄弟元素: '+'
后面所有的元素：'~'
```

###7. float 存在的问题

```
父元素高度塌陷
给一个元素设置浮动之后 float:left/right;，如果该元素的父元素有背景颜色，那么会发现父元素的背景颜色消失了；如果父元素有一个边框，那么浮动元素无法将边框撑开。

原因：

当元素设置浮动后，会自动脱离文档流，翻译成白话就是说，元素浮动后，就不在整个文档流的管辖范围，那么它之前存在在父元素内的高度就随着浮动不复存在了，而此时父元素会默认自己里面没有任何内容（前提是未给父元素设置固定高度，如果父元素本身有固定高度，就不会出现这种情况）

解决方法：

1.给父元素也添加float。这样让父元素与子元素一起脱离文档流浮动起来，保证子元素在父元素内，这样父元素就能自适应子元素的高度，但是此方法有一弊端，一定会影响父元素之后的元素排列，甚至影响布局。
2.给父元素一个固定高度，此方法适用于子元素高度已知并且固定的情况。
3.添加一个块级元素，并给此元素设置clear:both;清除浮动。在很早之前用的就是这种解决办法，新建一个空的div，为这个div设置clear：both；这样无疑是增加了无意义的标签，一个大型页面中，这种标签太多是不好的。
4.给父元素添加 overflow：hidden；
5.通过伪类::after清除浮动

```

###8. 什么是 bfc？能解决什么问题？如何开启 bfc？

```
1.BFC是指什么？
BFC = Block Formatting context 意思是块格式化上下文，BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素无论如何布局，都不会影响到区域外元素的布局。 这个渲染区域只对块级元素起作用。

2.常见的触发BFC有什么方式
1.浮动元素（float不为none）
2.绝对定位的元素（position为absolute或者fixed）
3.overflow不为visible的块级元素
4.display值为flex、 flow-root 、inline-block、table-cell等

3.BFC解决了什么问题？
1.浮动元素的父元素高度塌陷问题
2.两栏自适应布局问题
3.外边距垂直方向重合问题

```

###9. 基本数据类型（7 种）
###10. 判断数组的方法

```
1.  instanceof
    arr  instanceof Array

2. __proto__
    arr.__proto__  === Array.prototype

3. constructor
    arr.constructor === Array

4. Object.prototype.toString
   Object.prototype.toString.call(arr) === '[object Array]'

5. Array.isArray
    Array.isArray(arr)

其中方法1，2，3 主要是通过原型去判断的， 4是通过object类型的副属性class去判断的，其中函数的class是Function，结果是[object Function]， 普通的对象是Object，结果是[object Object]，5是es6新增的方法

```

###11. 其他类型转 Boolean

```
一、String类型转化为Boolean
1.转化结果为true的情况
①任何非空字符串
PS:空白字符串也是返回true
2.转化结果为false的情况
①空字符串

二、Number类型转化为Boolean
1.转化结果为true的情况
①任何非0数字值（包括无穷大）
2.转化结果为false的情况
①0
②NaN

三、Object类型转化为Boolean
1.转化结果为true的情况
①任何对象（包括空的对象）
②数组对象（包括空数组）
③正则表达式
2.转化结果为false的情况
①空对象
PS：这里要跟前面的空的对象{}作区分，空的对象表示这个对象创建了，但是里面没东西，而空对象表示的是没有创建，就是一个null

四、Undefined类型转化为Boolean
1.只能返回false
```

###12. (1+'1'=?)("1"+1=?) (''+[]=?)(''+{}=?)(1+[]=?)

```
前者都为 '11'
调用tostring()转为字符串再相加
```

###13. && 和 || 的区别

```
&&和|| 称为条件布尔运算符。
如果&&运算符的第一个操作数是false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是false。
同样，如果第一个操作数是true，||运算符就返回true，无需考虑第二个操作数的值。但&和|却不是这样，它们总是要计算两个操作数。

因为操作数的就算是有条件的，如果使用&&和||运算符来代替&和|，性能会有一定提高。在大量使用这些运算符的应用程序中这表现得尤为明显。
作为一个原则，尽可能使用&&和||运算符。

```

###14. == 和 === 的区别

```
“ == ”和“ === ”，都是判断运算符。
“==”模糊等，意思就是在做运算判断时，只需其值相等即可，因为在运算之前会进行一个隐式转换，可以将等式两边的数值转换成相同类型，然后再进行判断。
“===”绝对等，意思就是在做运算判断时，等式两边的数值以及数据类型都必须相同。
```

###15. 浅拷贝和深拷贝

```
拷贝：浅拷贝拷贝时会在堆中创建一个新的内存来保存原始对象的数据，当原始对象中只有简单数据类型的时候，拷贝的其实就 是基本数据类型的值，这时会给人造成一种迷惑看似是深拷贝。但当原始对象中有复杂数据类型时，只能拷贝原始对象内的复杂数据类型的指针去指向原始对象的复杂数据类型在堆中的空间内的数据。
浅拷贝是地址值的拷贝
浅拷贝就是只能拷贝单一层级的对象，无法拷贝多层级别的对象。

深拷贝：深拷贝就是拷贝原始对象的***所有层级***，不管原始对象中存在的是何种数据类型数据，都会将数据完整的复制一份，放入新开辟的空间，并且赋予新的指针，和原始对象互不干扰。
```

###16. JSON.stringify()方法

```
let arr = [1, 3, {
            username: 'zs'
        }, function say() {
            console.log('你好');
        }];
        let arr1 = JSON.parse(JSON.stringify(arr));
        arr1[1] = 2222;
        arr1[2].username = '小葱';
        console.log(arr);
通过运行结果可以清晰的看到：通过拷贝后的arr1去修改数据，原始对象的数据完全不受影响，但要注意的是 拷贝后对象内的函数消失了。

**注意：**JSON.parse(JSON.stringify())方法，虽然可以实现数组或对象深拷贝,但不能处理函数和正则，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。

```

###17. 数组的方法，哪些可以改变数组本身

```
concat
返回合并后的数组,不会改变原数组

concat
返回合并后的数组,不会改变原数组

reverse
会改变原数组

push
将一个元素从数组的最后面添加,会改变原数组

pop
将数组头部删除一个元素,返回被删除的元素会改变原数组

unshift
将数组头部增加一个元素,会改变原数组

shift
将数组尾部删除一个元素,返回被删除的元素会改变原数组

slice
截取,返回被截取的对象以数组的形式,不会改变原数组

splice
splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。

sort
排序方法,会改变原数组

isArray
判断一个值是不是数组,不会改变原数组
也有其他方法typeof()/instanceof()等

for
for 循环在JavaScript 刚萌生的时候就出现了，for循环是使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。for循环没有返回值,会改变原数组

forEach
遍历数组中的每一项，没有返回值，对原数组没有影响，但不支持IE,通过下标也会改变原数组

map
map() 的回调函数中支持 return 返回值，相当于把数组中的每一项改变，但并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了

filter
filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组。
注意：它不会改变原始数组，但是直接返回一个新数组。

every
every() 是对数组中的每一项运行给定函数，只有当该函数对每一项返回true，才返回true，否则返回false。

find
find() 方法返回数组中符合测试函数条件的第一个元素。否则返回undefined

findindex
findIndex() 用于找出第一个符合条件的数组成员的位置，如果没有找到返回 -1。
```
