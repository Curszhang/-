###1. js 函数调用参数传递是值传递还是引用传递

```
值传递：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
引用传递：在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
如果函数传递的是基本数据类型，那么就是值传递；如果函数传递是引用类型，那么就是引用传递。
```

###2. 原型和原型链

```
原型：
每一个函数天生自带一个属性，叫做 prototype，是一个对象
每一个对象自带一个属性__proto__ 指向所属构造函数的prototype
当你访问对象的成员的时候，首先是在自己的身上查找，如果没有，自动到__proto__ 上查找
我们把需要添加给实例的方法，放在构造函数的原型（prototype）上
就可以用实例进行访问使用
原型作用：由构造函数添加方法，专门给实例对象使用
构造函数也是函数，也会有这个自带的空间 prototype
既然 prototype 是一个对象，我们就可以使用对象操作的语法，向里面添加一些内容

原型链：
用 __proto__ 串联起来的对象链状结构
每一个对象数据类型都有一个属于自己的原型链
作用： 为了访问对象成员
对象访问机制：
当你需要访问成员的时候，首先在自己身上找，如果有直接使用，没有去自动去 __proto__  上查找，如果还没有，再去 __proto__ 上查找，知道object.prototype上都没有，那么就返回undefined
```

###3. 作用域和作用域链

```
作用域
作用域，就是变量或者是函数能作用的范围。
1.全局作用域
除了函数中定义的变量之外，都是全局作用域。
2.函数作用域
创建函数后在花括号中声明的一些语句或变量只在当前函数中起作用。
3.块级作用域
ES6带来的新特性，在语句块中声明的语句或变量只在当前语句块中起作用。
函数作用域和块级作用域根本没有直接关系,函数作用域在ES5和ES6作用完全一样,变量不论是使用var声明还是使用了let ,const声明在外部都是不可以访问的。
块级作用域指的就是使用 if () { }; while ( ) { } …这些语句所形成的语句块 , 并且其中变量必须使用let或const声明(否则就不是块级作用域了),保证了外部不可以访问语句块中的变量。

作用域链
当查找变量的时候，会先从当前作用域的变量对象中查找，如果没有找到，就会从父级作用域(上层环境)的变量对象中查找，一直找到全局作用域的变量对象，也就是全局对象。这样由多个作用域的变量对象构成的链表就叫做作用域链。它由当前环境与上层环境的一系列变量对象组成，保证了当前执行环境对符合访问权限的变量和函数的有序访问。
```

###4. 闭包的理解

```
1.闭包(closure):
function fn() {
    var num = 10;
    function fun() {
        console.log(num);
    }
    fun();
}
fn();
2.闭包的特点：
函数嵌套函数。
函数内部可以引用外部的参数和变量。
参数和变量不会被垃圾回收机制回收。
3.闭包的优点：
变量长期驻扎在内存中
避免全局变量的污染
私有成员的存在
4.闭包的缺点：
函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏。
```

###5. 内存溢出和内存泄漏

```
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

引起内存溢出的原因有很多种，小编列举一下常见的有以下几种：
1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
3.代码中存在死循环或循环产生过多重复的对象实体；
4.使用的第三方软件中的BUG；
5.启动参数内存值设定的过小

内存溢出的解决方案：
第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
```

###6. v8 引擎的垃圾回收机制

```
现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些垃圾回收机制的优化。
在JavaScript脚本中，绝大多数对象的生存期很短，只有部分对象的生存期较长。所以，V8 中的垃圾回收主要使用的是 分代回收 (Generational collection)机制。

分代回收机制
V8 中将堆内存分为 新生代 和 老生代 两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。
新生代 的内存一般都不大，所以使用 Scavenge 算法 进行垃圾回收效果比较好。老生代 一般占用内存较大，因此采用的是 标记清除算法。
新生代 的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。
V8 引擎将保存对象的 堆 (heap) 进行了分代，V8 整个堆内存的大小就等于新生代加上老生代的内存

```

###7. 创建 Object 实例对象的方式

```
1.对象实例化
2.字面量声明法
3.工厂模式
4.构造函数
5.原型对象
```

###8. 继承模式

```
1.原型链继承
将构造函数的原型设置为另一个构造函数的实例对象，这样就可以继承另一个原型对象的所有属性和方法，可以继续往上，最终形成原型链。
2.借用构造函数继承
为了解决原型中包含引用类型值的问题，开始使用借用构造函数，也叫伪造对象或经典继承
3.组合继承
也叫伪经典继承，将原型链和借用构造函数的技术组合到一块。使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。
4.原型式继承
不自定义类型的情况下，临时创建一个构造函数，借助已有的对象作为临时构造函数的原型，然后在此基础实例化对象，并返回。
5.寄生式继承
其实就是在原型式继承得到对象的基础上，在内部再以某种方式来增强对象，然后返回。
6.寄生组合式继承
组合继承是JS中最常用的继承模式，但其实它也有不足，组合继承无论什么情况下都会调用两次超类型的构造函数，并且创建的每个实例中都要屏蔽超类型对象的所有实例属性。
寄生组合式继承就解决了上述问题，被认为是最理想的继承范式。
```
